/* 
 This file was generated by Dashcode.
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
	debug( "load()" );
	dashcode.setupParts();
	UIinit();
	initAccounts();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
	// Stop any timers to prevent CPU usage
	// Remove any preferences as needed
	// widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	debug( "remove()" );
	
	for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
		if ( g_MailAccounts[acc].handler ) {
			g_MailAccounts[acc].handler.kill();
		}
	}
	
	deletePreferences();
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
	// Stop any timers to prevent CPU usage
	debug( "hide()" );
	
	g_shiftDown = false;
	UIshowZoomButton();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
	// Restart any timers that were stopped on hide
	debug( "show()" );
	
	if ( !g_checkInterval || g_checkOnShow ) {
		collectiveCheckMail();
	}
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
	// Retrieve any preference values that you need to be synchronized here
	// Use this for an instance key's value:
	// instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	//
	// Or this for global key's value:
	// globalPreferenceValue = widget.preferenceForKey(null, "your-key");
	
	debug( "sync()" );
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
	debug( "showBack( " + event + " )" );

	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.setCloseBoxOffset( 12, 13 );
		widget.prepareForTransition("ToBack");
	}

	front.style.display = "none";
	back.style.display = "block";
	
	if (window.widget) {
		setTimeout('widget.performTransition();', 200);
	}
	
	// Aktuelles Anzeige-Element in StackLayout abfragen
	var stackLayout = document.getElementById('settingsStackLayout').object; // Ersetzen durch ID des StackLayouts
	var currentView = stackLayout.getCurrentView();
	
	if ( currentView.id == "audioPlayerSettings" ) {
		g_pasteTarget = 2;
	} else {
		g_pasteTarget = 0;
	}
	
	UIentitle();
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
	debug( "showFront( " + event + ")" );

	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.setCloseBoxOffset( 24, 33 );
		widget.prepareForTransition("ToFront");
	}

	front.style.display="block";
	back.style.display="none";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
	
	g_pasteTarget = 1;
	UIdisplayName();
	UIentitle();
	UIblurAudio();
	deletePreferences();
	savePreferences();
	collectiveCheckMail();
}

if (window.widget) {
	widget.onremove = remove;
	widget.onhide = hide;
	widget.onshow = show;
	widget.onsync = sync;
}


ginit_MailAccountsGetter = null;
var g_MailAccounts = new Array();
var g_autoUpdateManager = null;

function initAccounts()
{
	debug( "initAccounts()" );
	
	ginit_MailAccountsGetter = new kwasiMailAccounts( g_MailAccounts );
	ginit_MailAccountsGetter.acquireMailAccounts( initAccounts2 );
}

function initAccounts2()
{
	debug( "initAccounts2()" );
	
	delete ginit_MailAccountsGetter;
	
	for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
		UIaddToAccountList( g_MailAccounts[acc].AccountName );
	}
	
	UIaddToAccountList( false ); //this causes a List-View refresh
	loadOldPreferences();
	loadPreferences();
}

var g_newMailCount = 0;

function collectCount(event)
{
	debug( "collectCount( " + event + " )" );
	
	g_newMailCount += event;
}

function collectFail( event )
{
	debug( "collectFail()!!!" );
	
	collectDone( event );
}

var g_pollAppleMail = null;

function pollAppleMail()
{
	debug( "pollAppleMail()" );
	
    var mailCount = MailWidgetPlugin.getAppleMailUnreadCount();
    debug( mailCount );
	
    if ( mailCount && ( mailCount[0] != -1 ) ) {
        UIbadgeCount( mailCount[0] );
		
		if ( mailCount[0] > 0 ) {
			var from = mailCount[1];
			var subject = mailCount[2];
			var date = new Date( mailCount[3] );
			var account = mailCount[4];
			
			debug( date );
			
			//fix me : computed date is wrong
			if ( date.toString() == "Invalid Date" ) { //try ISO 8601
				debug( "Trying to parse ISO 8601" );
				date = String( mailCount[3] );
				debug( date );
				var iso = date.match( /(\d*)-(\d*)-(\d*) (\d*)\:(\d*)\:(\d*)/ );
			
				if ( iso.length == 7 ) {
					date = new Date( iso[1], iso[2] - 1, iso[3], iso[4], iso[5], iso[6] );
				}
			}
			
			debug( date );
			
			UIsetMailHeader( from, subject );
			
			if ( date > g_DateLast ) {
				g_DateLast = date;
				UIgrowlAnnouncement( mailCount[0], from, subject );
				UIplayAudio();
			}
		}
    }
}

var g_growlFromPrev = "";
var g_growlSubjectPrev = "";
var g_DateLast = new Date( 0 );

function collectDone( event )
{
	debug( "collectDone()" );
	
	g_checkMailCounter--;
	
	if ( !g_checkMailCounter ) {
		UIactivityIndicator( false );
		UIbadgeCount( g_newMailCount );
		
		var from = "";
		var subject = "";
		var date = new Date( 0 );
		
		debug( "date : " + date );
		debug( "g_collectedMailHeaders : " + g_collectedMailHeaders );
		
		for ( var mail = 0; mail < g_collectedMailHeaders.length; mail++ ) {
			debug( g_collectedMailHeaders[mail]["date"] );
			
			if ( (g_collectedMailHeaders[mail]["from"] != "") || (g_collectedMailHeaders[mail]["subject"] != "") ) {
				if ( g_collectedMailHeaders[mail]["date"] > date ) {
					from = g_collectedMailHeaders[mail]["from"];
					subject = g_collectedMailHeaders[mail]["subject"];
					date = g_collectedMailHeaders[mail]["date"];
				}
			}
		}
		
		debug( from );
		
		if ( from.length ) {
			debug( "/usr/bin/perl MailHeaderDecoding.pl \"" + from + "\"" );
			from = widget.system( "/usr/bin/perl MailHeaderDecoding.pl \"" + from + "\"", null ).outputString;
		}
		
		debug( from );
		
		if ( from == undefined ) {
			from = "-";
		}
		
		debug( from );
		
		if ( subject.length ) {
			subject = widget.system( "/usr/bin/perl MailHeaderDecoding.pl \"" + subject + "\"", null ).outputString;
		}
		
		if ( subject == undefined ) {
			subject = "-";
		}
		
		UIsetMailHeader( from, subject );
		
		if ( date > g_DateLast ) {
			g_DateLast = date;
			UIgrowlAnnouncement( g_newMailCount, from, subject );
			UIplayAudio();
            MailWidgetPlugin.appleMailCheck();
		}
	}
}

var g_collectedMailHeaders = new Array();

function collectHeaders( FROM, SUBJECT, DATE ) {
	debug( "collectHeaders( " + FROM + ", " + SUBJECT + ", " + DATE + " )" );

	var temp = new Object();
	temp["from"] = FROM;
	temp["subject"] = SUBJECT;
	debug( DATE );
	temp["date"] = new Date( DATE );
		
	debug( "temp[\"date\"] : " + temp["date"] );
	
	debug( DATE );
	debug( temp["date"] );
	
	//Mon, 9 Nov 2009 12:54:08 (+)0100
	if ( temp["date"].toString() == "Invalid Date" ) { //try fixing missing + for timezone
		debug(DATE);
		var dateString = DATE.match( /\d{1,2}\s+\w{3}\s+\d{4}\s+\d+\:\d+\:\d+\s+(\+|\-)?(\d{4})/ );
		debug( dateString )
		
		if ( dateString && dateString[1] == undefined ) {
			dateString = DATE.replace( /(\d{1,2}\s+\w{3}\s+\d{4}\s+\d+\:\d+\:\d+\s+)(?:\+|\-)?(\d{4})/, "$1+$2" );
			temp["date"] = new Date( dateString );
		}
	}
	
	debug( temp["date"] );
	
	//fix me : computed date is wrong
	if ( temp["date"].toString() == "Invalid Date" ) { //try ISO 8601
		debug( "Trying to parse ISO 8601" );
		var iso = DATE.match( /(\d*)-(\d*)-(\d*).(\d*)\:(\d*)\:(\d*)Z/ );
		
		if ( iso && iso.length == 7 ) {
			temp["date"] = new Date( Date.UTC( iso[1], iso[2] - 1, iso[3], iso[4], iso[5], iso[6] ) );
		}
	}
	
	debug( temp["date"] );
	
	debug( "temp[\"date\"] : " + temp["date"] );
	
	if ( temp["date"].toString() == "Invalid Date" ) { //failed to parse Date, set NOW
		debug( "Fatal error. Cannot parse Date" );
		temp["date"] = new Date( 1 );
	}
	
	debug( "temp[\"date\"] : " + temp["date"] );
	g_collectedMailHeaders.push( temp );
}

g_checkMailCounter = 0;

function collectiveCheckMail()
{
	debug( "collectiveCheckMail()" );

	UIactivityIndicator( true );
	g_newMailCount = 0;
	g_checkMailCounter = 0;
	delete g_collectedMailHeaders;
	g_collectedMailHeaders = new Array();
	
	for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
		if ( g_MailAccounts[acc].handler ) {
			g_checkMailCounter++;
			debug( "testing " + g_MailAccounts[acc].AccountName );
			g_MailAccounts[acc].handler.checkMail();
		}
	}
	
	if ( !g_checkMailCounter ) {
		UIactivityIndicator( false );
	}
}

function loadOldPreferences()
{
	debug( "loadOldPreferences()" );
	
	//fix me: merge activeMailAccounts which contains Names with activeAccountList which contains UUIDs
	var activeMailAccounts = new Array();
	var activeAccountList = new Array();
	
	for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
		var preferenceForKey = g_MailAccounts[acc].uniqueId;
		preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
		
		if ( preferenceForKey ) {
			MailWidgetPlugin.setPassword( g_MailAccounts[acc].uniqueId, atob( preferenceForKey ) );
			widget.setPreferenceForKey( null, widget.identifier + "-" + g_MailAccounts[acc].uniqueId );
			activeAccountList.push( g_MailAccounts[acc].uniqueId );
		}
	}
	
	if ( activeAccountList.length > 0 ) {
		widget.setPreferenceForKey( activeAccountList.join( ";" ), widget.identifier + "-" + "Accounts" );
	}
	
	var preferenceForKey = "audioVolume";
	preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
	
	if ( preferenceForKey != undefined ) {
		if ( preferenceForKey > 1 ) {
			preferenceForKey /= 256;
			widget.setPreferenceForKey( preferenceForKey, widget.identifier + "-" + "audioVolume" );	
		}
	}
	
	var tempCustomAudio = new Array();
	
	for ( var snd = 0; snd < 32; snd++ ) {
		var preferenceForKey = "customAudio" + snd;
		preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
		
		if ( preferenceForKey ) {
			tempCustomAudio.push( preferenceForKey );
		}
	}
	
	if ( tempCustomAudio.length > 0 ) {
		for ( var snd = 0; snd < 32; snd++ ) {
			widget.setPreferenceForKey( null, widget.identifier + "-" + "customAudio" + snd );
		}
		
		widget.setPreferenceForKey( tempCustomAudio.join( ";" ), widget.identifier + "-" + "customAudio" );
	}
}

function loadPreferences()
{
	debug( "loadPreferences()" );
	
	var activeMailAccounts = new Array();
	var preferenceForKey = "Accounts";
	preferenceForKey = widget.preferenceForKey( widget.identifier + "-" + preferenceForKey );
	
	if ( preferenceForKey != undefined ) {
		for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
			var accountID = g_MailAccounts[acc].uniqueId;
			
			if ( preferenceForKey.indexOf( accountID ) != - 1 ) {
				g_MailAccounts[acc].Password = MailWidgetPlugin.getPassword( accountID );
				applyLoadedAccount( acc );
				activeMailAccounts.push( g_MailAccounts[acc].AccountName );
			}
		}
	}
	
	MailWidgetPlugin.setActiveAccounts( activeMailAccounts );
	
	var preferenceForKey = "checkOnShow";
	preferenceForKey = widget.preferenceForKey( widget.identifier + "-" + preferenceForKey );
	
	if ( preferenceForKey != undefined ) {
		UIsetCheckOnShow( preferenceForKey );
	}	
	
	var preferenceForKey = "checkInterval";
	preferenceForKey = widget.preferenceForKey( widget.identifier + "-" + preferenceForKey );
	
	if ( preferenceForKey != undefined ) {
		UIsetCheckInterval( preferenceForKey );
	} else {
		UIsetCheckInterval( 15 );
	}
	
	var preferenceForKey = "audioVolume";
	preferenceForKey = widget.preferenceForKey( widget.identifier + "-" + preferenceForKey );
	
	if ( preferenceForKey != undefined ) {
		UIsetVolume( preferenceForKey );
	} else {
		UIsetVolume( 1 );
	}
	
	var preferenceForKey = "customAudio";
	preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
	
	if ( preferenceForKey != undefined ) {
		g_customAudio = preferenceForKey.split( ";" );
		UIaudioDragLeave();
	}
	
	var preferenceForKey = "autoUpdate";
	preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
	
	if ( preferenceForKey != undefined ) {
		UIsetUpdate( preferenceForKey );
	} else {
		UIsetUpdate( true );
	}
    
    var preferenceForKey = "growl";
	preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
	
	if ( preferenceForKey != undefined ) {
		UIsetGrowl( preferenceForKey );
	} else {
		UIsetGrowl( true );
	}
	
	var preferenceForKey = "name";
	preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
	
	if ( preferenceForKey != undefined ) {
		UIsetName( preferenceForKey );
	}
	
	var preferenceForKey = "mini";
	preferenceForKey = widget.preferenceForKey(widget.identifier + "-" + preferenceForKey);
	
	if ( preferenceForKey != undefined ) {
		UItoggleMini();
	}
	
	if ( g_autoUpdate ) {
		g_autoUpdateManager = new kwasiAutoUpdate( 12 * 60 * 60 * 1000, "http://support.kwasi-ich.de/MailWidgetUpdate.xml?" + widget.identifier, UIaskForUpdate, UIsetVersionString );
//		g_autoUpdateManager.checkForUpdate();
	}
	
	UIdisplayName();
//	g_wakeAfterSleep = new kwasiSleep( wakeUp, 300000, 15000 );
	collectiveCheckMail();
}

function applyLoadedAccount(event)
{
	debug( "applyLoadedAccount( " + event + " )" );
	
	if ( g_MailAccounts[event].AccountType == "POPAccount" ) {
		//handle POP3
		g_MailAccounts[event].handler = new kwasiPopClient( g_MailAccounts[event], collectCount, collectHeaders, collectFail, collectDone );
	} else if ( g_MailAccounts[event].AccountType == "EWSAccount" ) {
		//handle Exchange 2007
		g_MailAccounts[event].handler = new kwasiExchangeClient( g_MailAccounts[event], collectCount, collectHeaders, collectFail, collectDone );
	} else {
		//handle IMAP
		g_MailAccounts[event].handler = new kwasiImapClient( g_MailAccounts[event], collectCount, collectHeaders, collectFail, collectDone );
	}
	
	UIsetIndicator(event, 1);
}


function savePreferences()
{
	debug( "savePreferences()" );
	
	//fix me: merge activeMailAccounts which contains Names with activeAccountList which contains UUIDs
	var activeMailAccounts = new Array();
	var activeAccountList = new Array();
	
	for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
		if ( g_MailAccounts[acc].handler ) {
			//widget.setPreferenceForKey( btoa(g_MailAccounts[acc].Password), widget.identifier + "-" + g_MailAccounts[acc].uniqueId );
			//fix me: add me
			MailWidgetPlugin.setPassword( g_MailAccounts[acc].uniqueId, g_MailAccounts[acc].Password );
			activeMailAccounts.push( g_MailAccounts[acc].AccountName );
			activeAccountList.push( g_MailAccounts[acc].uniqueId );
		} else {
			//widget.setPreferenceForKey( null, widget.identifier + "-" + g_MailAccounts[acc].uniqueId );
			//fix me: add me
			//MailWidgetPlugin.deletePassword( g_MailAccounts[acc].uniqueId );
		}
	}
	
	widget.setPreferenceForKey( activeAccountList.join( ";" ), widget.identifier + "-Accounts" );
	MailWidgetPlugin.setActiveAccounts( activeMailAccounts );
	
	widget.setPreferenceForKey( g_checkOnShow, widget.identifier + "-" + "checkOnShow" );
	widget.setPreferenceForKey( g_checkInterval, widget.identifier + "-" + "checkInterval" );
	widget.setPreferenceForKey( g_audioVolume, widget.identifier + "-" + "audioVolume" );	
	
	if ( g_customAudio ) {
		//for ( var snd = 0; snd < g_customAudio.length; snd++ ) {
		//	widget.setPreferenceForKey( g_customAudio[snd], widget.identifier + "-" + "customAudio" + snd );
		//}
		
		widget.setPreferenceForKey( g_customAudio.join( ";" ), widget.identifier + "-" + "customAudio" );
	}
	
	widget.setPreferenceForKey( g_autoUpdate, widget.identifier + "-" + "autoUpdate" );
    widget.setPreferenceForKey( g_growl, widget.identifier + "-" + "growl" );
	widget.setPreferenceForKey( g_name, widget.identifier + "-" + "name" );
}


function deletePreferences()
{
	debug( "deletePreferences()" );
	
	widget.setPreferenceForKey( null, widget.identifier + "-Accounts" );
	
	//for ( var acc = 0; acc < g_MailAccounts.length; acc++ ) {
	//	widget.setPreferenceForKey( null, widget.identifier + "-" + g_MailAccounts[acc].uniqueId );
	//	fix me: add me
	//	MailWidgetPlugin.deletePassword( g_MailAccounts[acc].uniqueId );
	//}
	
	widget.setPreferenceForKey( null, widget.identifier + "-" + "checkOnShow" );
	widget.setPreferenceForKey( null, widget.identifier + "-" + "checkInterval" );
	widget.setPreferenceForKey( null, widget.identifier + "-" + "audioVolume" );	
	
	//for ( var snd = 0; snd < 32; snd++ ) {
	//	widget.setPreferenceForKey( null, widget.identifier + "-" + "customAudio" + snd );
	//}
	
	widget.setPreferenceForKey( null, widget.identifier + "-" + "customAudio" );

	widget.setPreferenceForKey( null, widget.identifier + "-" + "autoUpdate" );
    widget.setPreferenceForKey( null, widget.identifier + "-" + "growl" );
	widget.setPreferenceForKey( null, widget.identifier + "-" + "name" );
	widget.setPreferenceForKey( null, widget.identifier + "-" + "mini" );
}

var g_checkIntervalManager = null; //setInterval( collectiveCheckMail, 10 * 60 * 1000 );

//var g_wakeAfterSleep = null;

function resetInterval()
{
	debug( "resetInterval()" );

	debug( g_checkInterval );
	clearInterval( g_checkIntervalManager );
	
	if ( g_checkInterval ) {
		g_checkIntervalManager = setInterval( collectiveCheckMail, g_checkInterval * 60 * 1000 );
	} else {
		g_checkIntervalManager = null;
	}
}

//function wakeUp()
//{
//	debug( "wakeUp()" );
//	
//	if ( g_checkInterval ) {
//		resetInterval();
//		collectiveCheckMail();
//	}
//}

function connectivity( reachable ) {
	debug( "connectivity( " + reachable + " )" );
	
	if ( reachable ) {
		UInoConnection( false );
		
		if ( g_checkInterval ) {
			resetInterval();
			collectiveCheckMail();
		}
	} else {
		UInoConnection( true );
	}
}

function mailRunning( running ) {
	debug( "mailRunning( " + running + " )" );
	
	if ( running ) {
		pollAppleMail();
		g_pollAppleMail = setInterval( pollAppleMail, 10 * 1000 );
	} else {
		clearInterval( g_pollAppleMail );
	}
}

function debug( string )
{
	_debug( "main : " + string );
}

var _debugBuffer = "";

function _debug( STRING ) {
	return;
	STRING = STRING.replace( /\r/g, '' );
	var now = new Date();
	var x = 3;
	
	switch ( x ) {
		case 0:
			alert( STRING );
			break;
		case 1:
			var stringLines = STRING.split( "\n" );
			
			for ( var line = 0; line < stringLines.length; line++ ) {
				alert( stringLines[line] );
			}
			
			break;
		case 2:
			_debugBuffer += now;
			_debugBuffer += '\n';
			_debugBuffer += STRING;
			_debugBuffer += '\n';
			
			if ( _debugBuffer.length > 4096 ) {
				widget.system( "echo \"" + _debugBuffer + "\" >> ~/Desktop/MailWidget.log", function() {} );
				//alert( _debugBuffer );
				_debugBuffer = "";
			}
			
			break;
		case 3:
			MailWidgetPlugin.log( STRING );
			break;
		default:
			break;
	}
}

